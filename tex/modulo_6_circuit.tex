\documentclass[border=10pt]{standalone}
\usepackage{circuitikz}

\usetikzlibrary{backgrounds}
\begin{document}
\begin{circuitikz}[american, scale=1.0]
    \ctikzset{logic ports=ieee}
    \ctikzset{logic ports/fill=white} 
    % Flip-Flops
    \tikzset{d-ff/.style={flipflop, flipflop def={t1=D, t6=Q, t4=\ctikztextnot{Q}, c3=1}}}
    
    % Q-Bus Nodes
    \coordinate (Q2_bus) at (-5, 13);
    \coordinate (Q1_bus) at (-4, 13);
    \coordinate (Q0_bus) at (-3, 13);
    \coordinate (C_bus) at (-2, 13);
    
    % Draw Buses
    \draw (Q2_bus) node[above] {$Q_2$} -- (-5, -1);
    \draw (Q1_bus) node[above] {$Q_1$} -- (-4, -1);
    \draw (Q0_bus) node[above] {$Q_0$} -- (-3, -1);
    \draw (C_bus) node[above] {$C$} -- (-2, -1);
    
    \node (clk) at (6, -1) {CLK};
    
    % FFs
    \node[d-ff] (FF0) at (6, 1) {$Q_0$};
    \node[d-ff] (FF1) at (6, 5) {$Q_1$};
    \node[d-ff] (FF2) at (6, 9) {$Q_2$};
    
    % Clock distribution & Q Routing
    \begin{scope}[on background layer]
        \draw (clk) -| (FF0.pin 3);
        \draw (clk) -| (FF1.pin 3);
        \draw (clk) -| (FF2.pin 3);
        
        % Route Q to Bus
        \draw (FF0.pin 6) -- ++(1,0) -- ++(0, 5) -- ++(-11, 0) -- (-3, 6 |- Q0_bus); % Route Q0 up and over to -3
        % Wait, routing up and over might be messy. Let's route horizontally through the gap if possible or go up/down.
        % Actually, simpler: Route directly left if 'background' works well.
        % FF inputs (D) are on pin 1 (left). FF outputs (Q) are on pin 6 (right).
        % Drawing from right side back to left side requires going around.
        % Let's go UP from each Q, then LEFT above everything (y=12.5), then DOWN to the bus.
        
        % Q2 Route
        \draw (FF2.pin 6) -- ++(0.5,0) -- ++(0, 0.5) -- (-5, 9.5) -- (Q2_bus |- FF2.pin 6); % Just connect to the vertical line? No, the vertical line is the bus.
        % Let's just define the bus as the source.
        % We need to drive the bus FROM the FFs.
        % Route Q2
        \draw (FF2.pin 6) -- ++(0.5,0) -- ++(0, 2) -- (-5, 11) -- (-5, 9); % Connect to bus line at -5
        % Route Q1
        \draw (FF1.pin 6) -- ++(0.5,0) -- ++(0, 6) -- (-4, 11) -- (-4, 5); % Connect to bus line at -4
        % Route Q0
        \draw (FF0.pin 6) -- ++(0.5,0) -- ++(0, 10) -- (-3, 11) -- (-3, 1); % Connect to bus line at -3
        
        % Re-thinking routing: The FFs are stacked at x=6, y=1,5,9.
        % The logic is to the left (x=0..3).
        % The buses are further left (x=-5..-2).
        % So logic inputs take from buses. Logic outputs go to FF inputs (pin 1, left side).
        % FF outputs (pin 6, right side) need to go to buses (far left).
        % So loop back: Q -> Right -> Up/Down -> Left -> Bus
    \end{scope}
    
    % Better Routing Strategy:
    % Q2 (6,9) -> (7,9) -> (7,12) -> (-5,12) -> (-5, -1)
    % Q1 (6,5) -> (6.5,5) -> (6.5,12.2) -> (-4,12.2) -> (-4, -1)
    % Q0 (6,1) -> (6.2,1) -> (6.2,12.4) -> (-3,12.4) -> (-3, -1)
    
    \begin{scope}[on background layer]
        % Clock
        \draw (clk) -| (FF0.pin 3);
        \draw (clk) -| (FF1.pin 3);
        \draw (clk) -| (FF2.pin 3);
        
        % Q2 Feedback
        \draw[red] (FF2.pin 6) -- ++(0.5,0) -- ++(0, 3) -- (-5, 12) -- (-5, -1);
        % Q1 Feedback
        \draw[blue] (FF1.pin 6) -- ++(0.5,0) -- ++(0.2,0) -- ++(0, 7.2) -- (-4, 12.2) -- (-4, -1);
        % Q0 Feedback
        \draw[green] (FF0.pin 6) -- ++(0.5,0) -- ++(0.4,0) -- ++(0, 11.4) -- (-3, 12.4) -- (-3, -1);
    \end{scope}
    
    % Logic D0 = Q0 XOR C (D0 = Q0 + C)
    % D0 = Q0 XOR C.
    \node[xor port] (xor_d0) at (2, 1) {};
    \begin{scope}[on background layer]
        \draw (-3, 1 |- xor_d0.in 1) -- (xor_d0.in 1); % Q0
        \draw (-2, 1 |- xor_d0.in 2) -- (xor_d0.in 2); % C
        \draw (xor_d0.out) -- (FF0.pin 1);
    \end{scope}
    
    % Logic D2 = Q2 Q1' + Q2 Q0 C' + Q1 Q0 C
    % Terms
    \node[and port] (term1_d2) at (0, 11) {}; % Q2 Q0'
    \node[and port] (term2_d2) at (0, 9.5) {}; % Q2 C'
    \node[and port, number inputs=3] (term3_d2) at (0, 8) {}; % Q1 Q0 C
    \node[or port, number inputs=3] (or_d2) at (3, 9) {};

    % Connections D2
    \begin{scope}[on background layer]
        % Q2 Q0'
        % Input 1: Q2 from bus
        \draw (-5, 1 |- term1_d2.in 1) -- (term1_d2.in 1);
        % Input 2: Q0' (Q0 from bus + NOT)
        \node[not port, scale=0.6] (inv_q0_d2) at (-1, 11 |- term1_d2.in 2) {};
        \draw (-3, 1 |- inv_q0_d2.in) -- (inv_q0_d2.in); % Q0
        \draw (inv_q0_d2.out) -- (term1_d2.in 2);
        
        % Q2 C'
        % Input 1: Q2
        \draw (-5, 1 |- term2_d2.in 1) -- (term2_d2.in 1);
        % Input 2: C' (C from bus + NOT)
        \node[not port, scale=0.6] (inv_c_d2) at (-1, 9.5 |- term2_d2.in 2) {};
        \draw (-2, 1 |- inv_c_d2.in) -- (inv_c_d2.in);
        \draw (inv_c_d2.out) -- (term2_d2.in 2);
        
        % Q1 Q0 C
        \draw (-4, 1 |- term3_d2.in 1) -- (term3_d2.in 1); % Q1
        \draw (-3, 1 |- term3_d2.in 2) -- (term3_d2.in 2); % Q0
        \draw (-2, 1 |- term3_d2.in 3) -- (term3_d2.in 3); % C
        
        % OR
        \draw (term1_d2.out) -- (or_d2.in 1);
        \draw (term2_d2.out) -- (or_d2.in 2);
        \draw (term3_d2.out) -- (or_d2.in 3);
        \draw (or_d2.out) -- (FF2.pin 1);
    \end{scope}
    
    % Logic D1 = Q1 Q0' + Q1 Q0 C' + Q2' Q1' Q0 C
    % Terms
    \node[and port] (term1_d1) at (0, 6) {}; % Q1 Q0'
    \node[and port] (term2_d1) at (0, 4.5) {}; % Q1 C'
    \node[and port, number inputs=4] (term3_d1) at (0, 3) {}; % Q2' Q1' Q0 C
    \node[or port, number inputs=3] (or_d1) at (3, 5) {};
    
    % Connections D1
    \begin{scope}[on background layer]
        % Q1 Q0'
        \draw (-4, 1 |- term1_d1.in 1) -- (term1_d1.in 1); % Q1
        % Q0'
        \node[not port, scale=0.6] (inv_q0_d1) at (-1, 6 |- term1_d1.in 2) {};
        \draw (-3, 1 |- inv_q0_d1.in) -- (inv_q0_d1.in);
        \draw (inv_q0_d1.out) -- (term1_d1.in 2);
        
        % Q1 C'
        \draw (-4, 1 |- term2_d1.in 1) -- (term2_d1.in 1); % Q1
        % C'
        \node[not port, scale=0.6] (inv_c_d1) at (-1, 4.5 |- term2_d1.in 2) {};
        \draw (-2, 1 |- inv_c_d1.in) -- (inv_c_d1.in);
        \draw (inv_c_d1.out) -- (term2_d1.in 2);
        
        % Q2' Q1' Q0 C
        % Q2'
        \node[not port, scale=0.6] (inv_q2_d1) at (-1, 3 |- term3_d1.in 1) {};
        \draw (-5, 1 |- inv_q2_d1.in) -- (inv_q2_d1.in);
        \draw (inv_q2_d1.out) -- (term3_d1.in 1);
        % Q1'
        \node[not port, scale=0.6] (inv_q1_d1) at (-0.5, 3 |- term3_d1.in 2) {}; % Shift x slightly to avoid overlap
        \draw (-4, 1 |- inv_q1_d1.in) -- (inv_q1_d1.in);
        \draw (inv_q1_d1.out) -- (term3_d1.in 2);
        % Q0
        \draw (-3, 1 |- term3_d1.in 3) -- (term3_d1.in 3);
        % C
        \draw (-2, 1 |- term3_d1.in 4) -- (term3_d1.in 4);
        
        % OR
        \draw (term1_d1.out) -- (or_d1.in 1);
        \draw (term2_d1.out) -- (or_d1.in 2);
        \draw (term3_d1.out) -- (or_d1.in 3);
        \draw (or_d1.out) -- (FF1.pin 1);
    \end{scope}
    
    % Output Y = Q2 Q1' Q0
    \node[and port, number inputs=3] (and_y) at (10, 5) {};
    \begin{scope}[on background layer]
        \draw (-5, 1 |- and_y.in 1) -- (and_y.in 1); % Q2
        % Q1'
        \node[not port, scale=0.6] (inv_q1_y) at (9, 5 |- and_y.in 2) {};
        \draw (-4, 1 |- inv_q1_y.in) -- (inv_q1_y.in);
        \draw (inv_q1_y.out) -- (and_y.in 2);
        % Q0
        \draw (-3, 1 |- and_y.in 3) -- (and_y.in 3); % Q0
        \draw (and_y.out) -- ++(0.5,0) node[right] {$Y$};
    \end{scope}

\end{circuitikz}
\end{document}

\documentclass[border=10pt]{standalone}
\usepackage{circuitikz}
\usetikzlibrary{calc}

\begin{document}
\begin{circuitikz}[american, scale=1.0]
    \ctikzset{logic ports=ieee}
    \ctikzset{flipflops/scale=0.85}
    
    % Signals
    \node (clk_in) at (-2, 0) {Clock};
    \node (load_in) at (-2, 4.5) {Load};
    \node (count_in) at (-2, 3) {Count};
    
    % Data Inputs
    \foreach \i in {0,1,2,3} {
        \node (I\i) at ({(\i*5.5)}, 5.5) {$I_\i$};
    }
    
    % Flip-Flops
    \def\ffdist{5.5}
    
    \foreach \i [count=\n from 0] in {0,1,2,3} {
        \pgfmathsetmacro{\xpos}{\n*\ffdist}
        
        % JK Flip-Flop
        \node[flipflop JK] (FF\i) at (\xpos, 0) {};
        
        % Outputs
        \node[above] at (FF\i.n) {$FF_\i$};
        \draw (FF\i.pin 6) -- ++(0.5, 0) coordinate (Q\i_out);
        \draw (Q\i_out) -- ++(0.5, 0) node[circ, label={above:$A_\i$}] {};
        
        % Logic Implementation
        % J = (Load * I) + (~Load * Count * Carry)
        % K = (Load * ~I) + (~Load * Count * Carry)
        
        % We need an inverter for Load to get ~Load
        % Actually, let's just assume we have Load and ~Load (or generate ~Load once)
        
        % Create local I and ~I
        % Inverter for I_i
        \node[not port, rotate=-90, scale=0.6] (NOT_I\i) at ($(I\i) + (0.5, -0.8)$) {};
        \draw (I\i) -- ++(0,-0.4) -| (NOT_I\i.in);
        \draw (I\i) ++(0,-0.4) node[circ] {} -- ++(-0.5, 0) coordinate (I\i_raw); % Raw I signal down
        
        % Logic Gates
        % 1. AND for Load * I -> Drive J
        % 2. AND for Load * ~I -> Drive K
        % 3. AND for (~Load * Count * Carry) -> Drive J and K
        
        % Position Gates
        % AND_LOAD_J above FF
        \node[and port, scale=0.7] (AND_LJ_\i) at ($(FF\i) + (-1.5, 2.5)$) {};
        % AND_LOAD_K below AND_LJ
        \node[and port, scale=0.7] (AND_LK_\i) at ($(FF\i) + (-1.5, 1.0)$) {};
        % AND_COUNT above AND_LJ
        \node[and port, scale=0.7] (AND_CNT_\i) at ($(FF\i) + (-1.5, 3.5)$) {};
        
        % OR gate for J
        \node[or port, scale=0.7] (OR_J_\i) at ($(FF\i.pin 1) + (-0.8, 0.5)$) {};
         % OR gate for K
        \node[or port, scale=0.7] (OR_K_\i) at ($(FF\i.pin 3) + (-0.8, -0.5)$) {};
        
        % Wiring J
        \draw (AND_LJ_\i.out) |- (OR_J_\i.in 1);
        \draw (AND_CNT_\i.out) |- (OR_J_\i.in 2);
        \draw (OR_J_\i.out) -- (FF\i.pin 1);
        
        % Wiring K
        \draw (AND_LK_\i.out) |- (OR_K_\i.in 2); % Bottom input
        % Reuse Count logic for K input? Yes, same term.
        \draw (AND_CNT_\i.out) ++(0.1, 0) coordinate (tap_cnt_\i);
        \node[circ] at (tap_cnt_\i) {};
        \draw (tap_cnt_\i) -- ++(0.1, 0) |- (OR_K_\i.in 1); % Top input
        \draw (OR_K_\i.out) -- (FF\i.pin 3);
        
        % Connections to Inputs
        % AND_LJ: Load, I
        \draw (load_in) -| (AND_LJ_\i.in 1);
        \draw (I\i_raw) |- (AND_LJ_\i.in 2);
        
        % AND_LK: Load, ~I
        \draw (load_in) -| (AND_LK_\i.in 1);
        \draw (NOT_I\i.out) |- (AND_LK_\i.in 2);
        
        % AND_CNT: ~Load, Count/Carry
        % Invert Loaad?
        % Let's put a global inverter for Load at the input if possible, or per stage. 
        % Doing per stage for clarity of local blocks.
        \node[not port, scale=0.6] (NOT_LOAD_\i) at ($(AND_CNT_\i.in 1) + (-0.8, 0)$) {};
        \draw (load_in) -| (NOT_LOAD_\i.in);
        \draw (NOT_LOAD_\i.out) -- (AND_CNT_\i.in 1);
        
        % Count/Carry Input
        \ifnum\i=0
            \draw (count_in) -| (AND_CNT_0.in 2);
        \else
            % From previous stage Carry
            % Previous stage Q
            \pgfmathsetmacro{\prev}{int(\i-1)}
            
            % Generate Carry Logic using AND gate
            \node[and port, scale=0.6] (AND_CARRY_\prev) at ($(FF\prev)!0.6!(FF\i) + (0, 3)$) {};
            
            % Input 1: Carry in from previous
            \ifnum\prev=0
                \draw (count_in) -| (AND_CARRY_0.in 1);
            \else
                 \pgfmathsetmacro{\pprev}{int(\prev-1)}
                 \draw (AND_CARRY_\pprev.out) -- ++(0.1,0) |- (AND_CARRY_\prev.in 1);
            \fi
            
            % Input 2: Q_\prev
            \draw (Q\prev_out) ++(0.3, 0) coordinate (tap_Q_\prev);
            \node[circ] at (tap_Q_\prev) {};
            \draw (tap_Q_\prev) |- (AND_CARRY_\prev.in 2);
            
            % Output drives current AND_CNT
            \draw (AND_CARRY_\prev.out) |- (AND_CNT_\i.in 2);
        \fi
        
    }
    
    % Clock Distribution
    \coordinate (clk_line_y) at ($(FF0.pin 2) + (0, -1.5)$);
    \draw (clk_in) |- (clk_line_y);
    
    \foreach \i in {0,1,2,3} {
        \draw (FF\i.pin 2) -- (FF\i.pin 2 |- clk_line_y) node[circ] {};
    }
    
    % Fix logic for last connection
    % The loop logic for AND_CARRY is inside the \i loop.
    % We need to render connections properly.
    % The pseudo-code 'if \i=0' inside foreach needs translate to TeX \ifnum.

\end{circuitikz}
\end{document}

\documentclass[border=10pt]{standalone}
\usepackage{circuitikz}
\usetikzlibrary{calc}

\begin{document}
\begin{circuitikz}[american, scale=1.0]
    \ctikzset{logic ports=ieee}
    \ctikzset{flipflops/scale=0.85}
    
    % Signals
    \node (clk_in) at (-2.5, -2) {Clock};
    %\node (logic_1) at (-2, 6) {Logic 1};
  %  \node (up_in) at (-2, 4) {Up};
   % \node (down_in) at (-2, 2) {Down};
    
    % Flip-Flops
    % LSB (A0) on Left -> MSB (A3) on Right
    
    \def\ffdist{6}
    
    \foreach \i [count=\n from 0] in {0,1,2,3} {
        \pgfmathsetmacro{\xpos}{\n*\ffdist}
        
        % T Flip-Flop
        \node[flipflop T] (FF\i) at (\xpos, 0) {};
        
        % Outputs
        \node[above] at (FF\i.n) {$T_\i$};
        \draw (FF\i.pin 6) -- ++(0, 0) coordinate (Q\i_out);
        \draw (Q\i_out) -- ++(0.5, 0) node[label={right:$A_\i$}] {};
        
        % Qbar output needed for Down counting
        \draw (FF\i.pin 4) -- ++(0, 0) coordinate (Qbar\i_out);
    }
    
    % FF0 Logic: T=1
    \draw (FF0.pin 1) -- ++(-0.5, 0) coordinate (T0_stub);
    \draw (T0_stub) -- ++(-0.5,0) node[left] (logic_1) {'1'};
    
    % Cascading Carry/Borrow Logic
    % We need to generate T inputs for FF1, FF2, FF3.
    % T_i = (Up * Q_{i-1} * ... * Q_0) + (Down * Qbar_{i-1} * ... * Qbar_0)
    % Implemented as cascading AND gates.
    
    % Carry Chain (Up)
    % Borrow Chain (Down)
    
    % Stage 0 Logic to drive FF1 T input
    % Need: (Up * Q0) + (Down * Qbar0)
    % T1 = (Up * Q0) + (Down * Qbar0)
    % Actually simpler:
    % Carry0 = Up * Q0
    % Borrow0 = Down * Qbar0
    % T1 = Carry0 + Borrow0
    
    % AND gates position: between FFs, slightly up
    
    \foreach \i [count=\next from 1] in {0,1,2} {
        % Logic between FF\i and FF\next
        
        % Coordinates
        \coordinate (mid_x) at ($(FF\i)!0.5!(FF\next)$);
        
        % Upper AND gate (Up count)
        \node[and port, scale=0.7] (AND_UP_\i) at ($(mid_x) + (-0.5, 4.0)$) {};
        
        % Lower AND gate (Down count)
        \node[and port, scale=0.7] (AND_DOWN_\i) at ($(mid_x) + (-0.5, 2.5)$) {};
        
        % OR gate (Combines for T input of next FF)
        \node[or port, scale=0.7] (OR_\i) at ($(mid_x) + (1.0, 3.25)$) {};
        
        % Connections for AND_UP_\i
        % Input 1: Up Control (Cascaded or direct?)
        % Cascaded: Input comes from previous Up-AND output? 
        % Wait, cascading:
        % T1: Up*Q0 + Down*Qbar0.
        % T2: Up*Q0*Q1 + Down*Qbar0*Qbar1.
        % So Input 1 of AND_UP_1 is Output of AND_UP_0.
        % Input 2 is Q1.
        
        % Connections for AND_UP_\i
        \ifnum\i=0
            % First stage: Inputs are directly Up and Down signals
            % First stage: Inputs are directly Up and Down signals
            % Interlock: Down signal to AND_DOWN is (Down AND NOT Up)
            
            % Up Input
            \draw (AND_UP_0.in 1) -- ++(-3.5, 0) node[left] (up_in) {Up};
            
            % NOT Up
            \node[not port, scale=0.6, rotate=-90] (NOT_UP) at ($(up_in) + (1.0, -1.0)$) {};
            \draw (up_in-|NOT_UP.in) |- (NOT_UP.in);
            \draw node[circ] at (up_in-|NOT_UP.in) {};
            
            % Interlock AND gate
            \node[and port, scale=0.7] (AND_INTERLOCK) at ($(AND_DOWN_0.in 2) + (-1.5, 0)$) {};
            
            % Inputs to Interlock AND
            % In 1: NOT Up
            \draw (NOT_UP.out) |- (AND_INTERLOCK.in 1);
            % In 2: Down Input
            \draw (AND_INTERLOCK.in 2) -- ++(-1.0, 0) node[left] (down_in) {Down};
            
            % Output to AND_DOWN_0
            \draw (AND_INTERLOCK.out) -- (AND_DOWN_0.in 2);
        \else
            % Subsequent stages: Inputs from previous AND outputs
            \pgfmathsetmacro{\prev}{int(\i-1)}
            \draw (AND_UP_\prev.out) -- ++(0.2, 0) |- (AND_UP_\i.in 1);
            \draw (AND_DOWN_\prev.out) -- ++(0.2, 0) |- (AND_DOWN_\i.in 2);
        \fi
        
        % Q Connections
        % Connect Q\i to AND_UP_\i input 2
        \draw (Q\i_out) ++(0.2, 0) coordinate (tap_Q\i);
        \node[circ] at (tap_Q\i) {};
        \draw (tap_Q\i) |- (AND_UP_\i.in 2);
        
        % Connect Qbar\i to AND_DOWN_\i input 1
        \draw (FF\i.pin 4) |- (AND_DOWN_\i.in 1);
        
        % Inputs to OR gate
        \draw (AND_UP_\i.out) |- (OR_\i.in 1);
        \draw (AND_DOWN_\i.out) |- (OR_\i.in 2);
        
        \ifnum\i=2
            
        \else
        \draw node[circ] at (AND_UP_\i.out) {};
        \draw node[circ] at (AND_DOWN_\i.out) {};
        \fi
        
        % Output of OR gate drives T input of next FF
        \draw (OR_\i.out) -- ++(0.2, 0) |- (FF\next.pin 1);
    }
    
    % Clock Distribution
    \draw (clk_in) -| (FF3.pin 3);
    
    \foreach \i in {0,1,2} {
        \draw (FF\i.pin 3) -- (FF\i.pin 3 |- clk_in) node[circ] {};
    }

\end{circuitikz}
\end{document}

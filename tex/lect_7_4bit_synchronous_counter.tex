\documentclass[border=10pt]{standalone}
\usepackage{circuitikz}
\usetikzlibrary{calc}

\begin{document}
\begin{circuitikz}[american, scale=1.0]
    \ctikzset{logic ports=ieee}
    \ctikzset{flipflops/scale=0.85}
    
    % Signals
    \node (clk_in) at (-3, -1.5) {Clock};
   % \node (logic_1) at (0, 2) {Logic 1};
   % \node (count_en) at (-3, 2) {Count Enable}; % Optional, usually implicit or explicitly logic 1 if just a counter.
    % Let's use Logic 1 node for simple counter.
    
    % Flip-Flops
    % LSB (A0) on Left -> MSB (A3) on Right
    
    \def\ffdist{5.5}
    \def\gatey{1.8} % Y position for AND gates
    
    \foreach \i [count=\n from 0] in {0,1,2,3} {
        \pgfmathsetmacro{\xpos}{\n*\ffdist}
        
        % JK Flip-Flop
        \node[flipflop JK] (FF\i) at (\xpos, 0) {};
        
        % Outputs
        \node[above] at (FF\i.n) {$Q_\i$};
        \draw (FF\i.pin 6) -- ++(0.5, 0) coordinate (Q\i_out);
        \draw (Q\i_out) -- ++(0.5, 0) node[label={right:$A_\i$}] {};
        \ifnum\i=3
        \else
        
        \fi
        
        % Input Connections (J, K)
        % Create stubs
        \draw (FF\i.pin 1) -- ++(-0.5, 0) coordinate (J_stub_\i);
        \draw (FF\i.pin 3) -- ++(-0.5, 0) coordinate (K_stub_\i);
        % Connect J and K together
        \draw (K_stub_\i) to[short,-*] ($(J_stub_\i) + (0, 1.3)$);
        \node[circ] at (J_stub_\i) {};
    }
    
    % Logic Implementation
    
    % FF0: J=K=1
   % \draw (JK_common_0) -- ++(0, 2) coordinate (top_0);
   % \draw (top_0) -- (logic_1);
  %  \draw (logic_1) -- (count_en); % Put Logic 1/Enable
    
    % FF1: J=K=Q0 * Enable
    % Place AND gate between FF0 and FF1
    \node[and port, scale=0.8] (AND0) at ($(FF0)!0.5!(FF1) + (0, \gatey)$) {};
    
    \draw (AND0.in 1) -- ++(-4,0) node[left] {Enable};

    % Input 1: Enable (from FF0 input line)
   % \draw (top_0) -| (AND0.in 1);
    
    % Input 2: Q0
    \draw (Q0_out) ++(0.2, 0) coordinate (tap_Q0);
    \node[circ] at (tap_Q0) {};
    \draw (tap_Q0) |- (AND0.in 2);
    
    % Output to FF1
  %  \draw (AND0.out) -| (JK_common_1);
    
    % FF2: J=K=Q0*Q1
    % AND Gate 1
    % Inputs: Q1 and previous carry (Q0 or Enable? usually Q0*Enable)
    % A synchronous counter logic: 
    % T0 = 1
    % T1 = Q0
    % T2 = Q0*Q1
    % T3 = Q0*Q1*Q2
    
    % Place AND gate between FF1 and FF2
    \node[and port, scale=0.8] (AND1) at ($(FF1)!0.5!(FF2) + (0, \gatey)$) {};
    
    % Inputs to AND1: Q1 and Q0 (from logic line feeding FF1? No, from Q0 and Q1 directly)
    % Connect Q1 to AND1.in 2
    \draw (Q1_out) ++(0.2, 0) coordinate (tap_Q1);
    \node[circ] at (tap_Q1) {};
    \draw (tap_Q1) |- (AND1.in 2);

    \draw (AND0.out) |- (AND1.in 1);
    
    % Connect Q0 (carry) to AND1.in 1
    % We can tap from the line feeing FF1 inputs? 
    % The line feeding FF1 inputs comes from Q0.
 %   \draw (JK_common_1) ++(0, 0.5) coordinate (tap_carry_1);
  %  \node[circ] at (tap_carry_1) {};
  %  \draw (tap_carry_1) |- (AND1.in 1);
    
    % Output of AND1 to JK_common_2
  %  \draw (AND1.out) -| (JK_common_2);
    
    % FF3: J=K=Q0*Q1*Q2 = (Q0*Q1) * Q2 = AND1_out * Q2
    % Place AND gate between FF2 and FF3
    \node[and port, scale=0.8] (AND2) at ($(FF2)!0.5!(FF3) + (0, \gatey)$) {};
    
    % Inputs to AND2: Q2 and AND1_out
    % Tap AND1 output
    \draw (AND1.out) |- (AND2.in 1); % Top input
    
    % Tap Q2
    \draw (Q2_out) ++(0.2, 0) coordinate (tap_Q2);
    \node[circ] at (tap_Q2) {};
    \draw (tap_Q2) |- (AND2.in 2); % Bottom input
    
    % Output of AND2 to JK_common_3
  %  \draw (AND2.out) -| (JK_common_3);

    % Terminal Count / Carry Out: AND3 = (Enable*Q0*Q1*Q2) * Q3
    \node[and port, scale=0.8] (AND3) at ($(FF3) + (2.75, \gatey)$) {};
    
    % Input 1: Previous Carry (Input to FF3)
    \draw (AND2.out)|- (AND3.in 1);
    
    % Input 2: Q3
    \draw (Q3_out) ++(0.2, 0) coordinate (tap_Q3);
    \node[circ] at (tap_Q3) {};
    \draw (tap_Q3) |- (AND3.in 2);

    % Output
    \draw (AND3.out) -- ++(0.3, 0) node[right] {TC};
    
    % Clock Distribution (Synchronous)
    % Common clock line at bottom
    \coordinate (clk_line_y) at ($(FF0.pin 2) + (0, -1.5)$);
    \draw (clk_in) -| (FF3.pin 2);
    
    \foreach \i in {0,1,2} {
        \draw (FF\i.pin 2) -- (FF\i.pin 2 |- clk_line_y) node[circ] {};
    }
    
    % Label Clock
    %\node[left] at (clk_in) {CLK};
    % Clock symbol (triangle) is inside FF
    
\end{circuitikz}
\end{document}
